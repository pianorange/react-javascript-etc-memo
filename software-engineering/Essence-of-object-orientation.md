# 객체지향의 사실과 오해: 역할, 책임, 협력 관점에서 본 객체지향

1.  협력하는 객체들의 공동체

객체지향이란 실세계를 직접적으로 직관적으로 모델링할 수 있는 패러다임  
-> 객체지향 프로그래밍 = 현실속 존재하는 사물 최대한 유사하게 모방해 소프트웨어로 옮기는 작업  
-> 객체지향 소프트웨어는 실세계의 투영  
-> 객체란 현실세계 존재하는 사물의 추상화

But
실제 개발시 객체에 직접적 대응되는 실세계 사물 그다지 없다.  
객체, 사물간 개념적 거리는 유사성 찾기 어려울 정도로 먼 것이 일반적.

실세계의 방화벽 : 화재 확산 방지  
소프트웨어의 방화벽 : 네트워크 침입 방지

-> 비유의 적절성 떠나 소프트웨어 객체와 실세계 사물 사이 존재하는 연관성 희미하다.

- 객체지향의 목표 실세계 모방X
  -> 새로운 개념적 세계 창조하는 것

### 요청과 응답으로 구성된 협력

일상에서 발생하는 대부분의 문제 개인 혼자힘 보다 다른사람들과 함께 풀어나가는 경우가 많음.

- 문제 하나 해결 위해 다수의 사람과 역할 필요
- 프로세스에 따라 요청이 요청을 유발해서 연쇄적으로 요청 발생
  -> 응답도 마찬가지로 연쇄적으로 발생

손님(주문요청)->캐시어(제조요청)-> 바리스타(제조 후 전달)  
->캐시어(손님에게 전달)->손님(수령)

### 역할과 책임

협력하는 과정속에서 사람은 특정한 역할 부여받음

특정한 역할 = 특정한 책임 암시

- 선생님(역할) = 교육이라는 책임 내포

사람들이 협력 위해 특정한 역할 맡고 역하에 적합한 책임을 수행한 다는 사실은 몇가지 중요한 개념을 제시

- 여러 사람이 동일한 역할을 수행할 수 있다:  
  역할에 따르는 책임만 수행된다면 누가하던 상관없다.  
  -> 손님은 커피만 주문할 수 있다면 카페 계산원이 누구여도 상관없다.  
  -> 역할은 대체 가능성을 의미한다`대체가능 subsitutable`

- 책임을 수행하는 방법은 자율적으로 선택할 수 있다(`polymorphism`):  
  -> '라떼를 제조'에 대해 바리스타에 따라 라떼의 비율, 레시피 다를 수 있다.

- 한 사람이 동시에 여러 역할 수행할 수 있다:  
  -> 캐시어와 바리스타 역할 동시에 수행하는 것도 가능.  
  -> 현실세계에서는 한사람이 동시에 둘 이상 역할 수행하는 경우가 오히려 많다.

## 역할, 책임, 협력

### 기능 구현 위해 협력하는 객체들

- 일련의흐름을 아래와 같이 바꾸면 실생활의 프로세스를 객체지향의 문맥으로 옮겨올 수 있다.
  사람-> 객체  
  고객의 요청-> 메시지  
  에이전트 요청 처리하는 방법->메서드

### 역할과 책임 수행하며 협력하는 객체들

사람들은 커피주문과 같은 특정한 목표 위해 서로 협력.

협력의 핵심 = 책임 수행하는 역할들 간의 연쇄적인 요청과 응답을 통해 목표 달성한다는 것.

캔트백 "어떤 객체도 섬이 아니다."  
객체 공동체안에서 객체는 주어진 역할과 책임 다하는 동시에 더 큰 목적 이루기 위해 다른 객체와도 적극적으로 협력한다.

애플리케이션 기능 더 작은 책임으로 분할  
-> 책임은 적절한 역할 수행할 수 있는 객체가 수행  
-> 객체는 책임 수행 도중 다른 객체에 도움 요청하기도 함  
-> 결론적으로 시스템 = 역할과 책임 수행하는 객체로 분할되고 시스템의 기능은 객체 간의 연쇄적인 요청과 응답의 흐름으로 구성된 협력으로 구현

- 객체지향 설계는 적절한 객체에게 적절한 책임 할당하는 것에서 시작 됨

- 책임은 객체지향 설계의 품질을 결정하는 가장 중요한 요소
- 책임이 불문명한 객체는 애플리케이션의 미래를 불분명하게 만듬
- 객체의 역할 = 캐셔, 바리스타 같이 협력에 참여하는 객체에 대한 페르소나  
  -> 관련성 높은 책임의 집합.  
   - 여러 객체가 동일한 역할 수행 가능 - 역할은 대체 가능성 의미 - 각 객체 책임을 수행하는 방법 자율적으로 선택 가능 - 하나의 객체가 동시에 여러 역할 수행 가능

## 협력속에 사는 객체

애플리케이션의 윤곽 결정하는것은 역할, 책임, 협력이지만  
주체는 객체

- 객체는 애플리케이션 기능 구현 위해 존재.
- 협력의 품질 결정하는 것은= 분할된 책임을 담당하는 각 객체의 조화

#### 협력 공동체의 일원으로서 객체의 2가지 덕목

1. 객체는 '협력적'이어야 한다.  
   전지전능한 객체 god object 는 내부적 복잡도에 의해 자멸함  
   적절한 단위의 책임을 갖고 다른 객체와 상호작용가능해야 함.

2. 자율적이어야 한다.  
   충분히 개방적인 동시에 협력에 참여하는 방법은 각 객체가스스로 결정  
   -> 처리를 어떻게할지, 어떤 요청에 응답하고 반응할지는 자주적으로 결정

### 상태와 행동을 함께 지닌 자율적인 객체

객체를 흔히 상태(state)와 행동(behavior)함께 지닌 실체라고 정의

- 객체가 협력 참여위해 어떤 행동 한다면 그에 필요한 상태도 지녀야 함

ex) 커피를 제조하는 바리스타  
-> 레시피를 알고 있다 (상태)  
-> 레시피 기반으로 제조(행동)

객체의 자율성 객체 내부와 외부 명확하게 구분하는 것에서 시작됨  
private 쓰면 해결되고, 외부접근 getter setter 로 관리

- 객체의 사적인 부분은 객체 스스로 관리
- 객체 외부에서 일체 간섭할 수 없게 함
- 객체 외부 접근은 허락된 수단 통해서만 가능하도록 함  
  캡슐화
- 객체는 다른 객체가 무엇(what)을 수행하는지 알수 있지만 어떻게(how)수행하는지는 알수 없어야 함.

### 협력과 메시지

각 객체는 협력 위해 메시지를 주고받음  
객체지향 세계의 협력은 이 송수신 관계에 의해 규정됨.

### 메서드와 자율성

- 객체가 수신받은 메시지 처리하는 방법을 `메서드method`라고 부름
- 객체지향 프로그래밍 언어에서 메서드는 클래스 안에 포함된 함수 or 프로시저 통해 구현
- 런타임 중 실행 될 메서드가 선택될 수 있다는 점은 객체지향언어의 특징.  
  -> 절차지향언어는 실행코드 컴파일할때 결정됨

- 메시지와 메서드의 분리는 객체의 협력에 참여하는 객체들 간 자율성을 증진시킴.  
  ex) 캐셔는 바리스타에 커피제조 요청하지만 어떻게 만드는지는 몰라도 된다.  
  요청이 무엇인지 표현하는 메시지와  
  요청 처리위한 구체적인 방법인 메서드 분리는 객체 자율성 높이는 핵심 메커니즘

### 객체 지향의 본질

- 객체지향이란 `시스템`을 상호작용하는 자율적인 `객체들의 공동체`로 바라보고 객체 이용해 시스템을 분할하는 방법.
- 자율적인 객체란 상태와 행위를 함께 지니며 스스로 자기 자신을 책임지는 객체
- 객체는 시스템 행위 구현 위해 다른 객체와 협력 함.  
  협력 내에서 정해진 역할 수행하며 역할은 관련된 책임의 집합
- 객체는 다른 객체와 협력 위해 메시지를 보내고 메시지를 수신한 객체는 메시지 처리하는데 적합한 메서드를 자율적으로 선택

## 객체를 지향하라

초기 객체 지향 프로그래밍 언어 초점은 새로운 개념의 데이터 추상화 제공하는 클래스라는 빌딩 블록에 초점이 맞춰져 있었음  
-> 앨런 케이(Alan kay) 같은 객체지향 선구자들의 초기 의도와 달리 객체지향 = 클래스지향 이라는 인식이 퍼짐

- 자바스크립트같은 prototype 기반 객체지향 언어에서는 클래스가 존재하지 않으며, 오직 객체만이 존재.(지금은 있음)
- prototype기반 객체지향 언어에서는 상속역시 클래스가 아닌 위임(delegation)

- 클래스를 지나치게강조하는 관점은 객체의 캡슐화 저해하고 클래스를 서로 강하게 결합시키므로 주의

- 좋은 객체지향 설계를 위해 코드를 담는 클래스의 관점에서 메시지를 주고받는 객체의 관점으로 사고의 중심을 전환하는 게 중요.

# 02 이상한 나라의 객체

- 객체지향 페러다임은 지식 추상화  
  -> 추상화한 지식 객체 안에 캡슐화 해서 실세계 문제 내재된 복잡성 관리  
  -> 객체를 발견하고 창조하는 것 = 지식과 행동을 구조화하는 문제

### 객체지향과 인지능력

인간은 본능적으로 세상을 독립적이고 식별 가능한 객체의 집합으로 바라본다.

- 인간이 자각하는 객체는 물리적 경계 지닌 구체적 사물  
  But 인간의 인지능력 개념적 경계 지닌 개념 포함

- 객체란 인간이 분명하게 인지하고 구별할 수 있는 개념적, 구체적 사물
- 복잡한 주변을 분해함으로서 인간이 더 분명하게 인지할 수 있는 단위로 쪼개는 것이 객체지향

### 객체 그리고 소프트웨어나라

- 객체의 3요소 - 상태(state) - 행동(behavior) - 식별자(identity)
  객체란 식별 가능한 개체 또는 사물.  
  -> 소프트웨어 안에서 객체는 저장된 상태와 실행 가능한 코드를 통해 구현된다.

### 상태

왜 상태가 필요한가  
객체 주변과 상호작용에 어떻게 반응하는가는 그 시점까지 객체의 상태가 어떤가에 의해 좌우된다.  
-> 어떤 행동의 결과는 과거 행동의 결과에 의존  
-> 객체의 행동이력을 따라 결과를 판단하는 방법은 복잡하고 이해하기 어려움  
-> 여기서 상태 라는 개념이 고안

- 상태를 이용하면 과거의 모든 행동 이력을 확인하지 않고도 결과를 쉽게 파악할 수 있다.
- 상태를 이용하면 과거에 상관 없이 현재를 기반으로 객체의 행동양식을 이해할 수 있다.  
  -> 복잡성 완화

- 상태: 숫자, 문자열, 속도, 시간, 날짜, 참/거짓과 같은 단순한 값은 객체가 아님 (키, 양, 속도 등등)

- 객체의 상태를 구성하는 모든 특징을 통틀어 `프로퍼티(property)`라고 표현  
  -> 일반적으로 프로퍼티는 정적이며,
  프로퍼티 값은 시간의 흐름에 따라 변하기 때문에 동적이다.

- 프로퍼티의 구성 요소

  - 링크: 객체와 객체사이의 의미있는 연결. 참조 가능한 것을 의미
  - 속성 attribute: 객체를 구성하는 단순한 값

- 객체지향의 세계에서 객체는 자율적인 존재라는 점을 명심해야 함  
  -> 객체는 다른 객체의 상태에 직접 접근할 수도, 변경할 수도 없다.  
  -> 외부 객체는 간접적으로 객체의 상태 변경하거나 조회가능한 수단이 필요함  
  -> 이 때문에 행동(behavior)필요

## 행동

객체가 취하는 행동은 객체 자신의 상태를 변경시킴  
객체의 행동에 의해 객체의 상태가 변경되는 것은 행동이 부수효과(side effect) 초래하는 것 의미.

### 협력과 행동

어떤 객체도 섬이 아니다. 객체는 자신에게 주어진 책임을 완수하기 위해 다른 객체 이용하고 서비스 제공.

- 객체가 다른객체와 협력하는 유일한 방법은 요청을 보내는 것.  
  -> 간접적으로 영향미쳐야함

- 행동이란 외부의 요청 또는 수신된 메시지에 응답하기 위해 동작하고 반응하는 활동.

### 상태 캡슐화

- 객체는 상태를 캡슐안에 감춰둔 채 외부로 노출하지 않는다.
- 객체가 외부에 노출하는 것은 행동 뿐이며, 외부에서의 접근 방법또한 행동뿐이다.

- 객체의 행동 유발은 외부로부터 전달된 메시지지만, 상태를 변경할지 여부는 객체 스스로 결정.  
  -> 외부에서는 객체 상태가 변경된다는 사실조차 알지 못한다.

- 상태를 잘 정의된 행동 집합 뒤로 캡슐화 하는 것은 객체의 자율성 높이고 협력을 단순하고 유연하게 만듬

### 식별자

객체란 인간 인지능력 이용 식별 가능한 경계 가진 모든 사물 의미.  
객체 식별 가능 = 객체를 서로 구별 가능한 프로퍼티가 객체 안에 존재하는 것 의미  
-> 이 프로퍼티를 `식별자`

- `객체`와 `값`의 가장 큰 차이는 식별자의 유무

- `값(value)`은 숫자 문자열 날짜 금액 등 변하지 않는 양을 모델링  
  -> 값의 상태 변하지 않기 때문에 immutable state가진다고 표현  
  -> 두 인스턴스의 상태가 같다면 같은걸로 판단 (종이위에 1이 두개적혀있으면 2개의 같은 값인것과 같은 이치)  
  -> 이런 성질을 동등성(equality)라고 함

- `객체`는 시간에 따라 변경되는 상태포함, 행동을 통해 상태 변경  
  -> 가변상태 mutable state  
  -> 타입 같은 2객체의 상태가 완전히 같아도 그 둘은 별개로 인식  
  ex) 이름:앨리스, 키 170 인 사람 2명이 있어도 상태가 같지만 다른 사람  
  -> 상태를 기반으로 객체의 동일성 판단 불가한 이유는 객체의 상태가 시간의 흐름에 따라 변화하기 때문

- 객체의 고유성은 식별자를 통해 구분가능하며, 상태가 달라도 식별자가 같으면 같은 객체로 판단 가능 -> 동일성(identical)  
  ex) 어린시절의 앨리스 키160 단발머리 -> 성장한 앨리스 키 170 롱헤어  
  시간의 흐름에 따라 상태는 변했지만 같은 앨리스다

- `객체` 나타내는 클래스 = 참조객체, 엔티티 (Person)
- `값` 나타내는 클래스 = value object (Integer, Long)

- `객체`는 상태를 가지며 상태는 변경 가능하다
- 객체의 상태를 변경시키는 것은 객체의 행동이다
  - 행동의 결과는 상태에 의존적이며 상태를 이용해 서술할 수 있다
  - 행동의 순서가 실행 결과에 영향 미친다.
- 객체는 어떤 상태에 있더라도 유일하게 식별 가능하다.

### 기계로서의 객체

- 쿼리: 객체의 상태 조회하는 작업
- command : 객체의 상태를 변경하는 작업

- 객체가 외부에 제공하는 행동의 대부분은 쿼리와 명령으로 구성

### 행동이 상태를 결정한다

- 객체 설계시 함정

  - 상태를 중심으로 객체를 바라보면안된다!  
    ex) 앨리스 객체 설계시 객체에 필요한 상태(키, 나이, 위치)를 생각하고  
    상태를 변경하거나 조회할 행동을 고민

    1. 상태를 먼저 결정하면 캡슐회가 저해 됨  
       상태가 객체 내부로 캡슐화 되지 못하고 공용인터페이스에 노출될 확률 높아짐
    2. 객체를 협력자가 아닌 고립된 섬으로 만들 가능성 높음  
       객체는 문맥내에서 다른 객체와 협력하는데 입각해 설계되야 함  
       상태만 고려하면 자연스럽게 협력에 적합하지 못한 객체 설계로 이어짐
    3. 객체의 재사용성 저하  
       재사용성은 다양한 협력에 열려있는 능력에서 나옴
       -> 협력에 참여하는 좋은 객체 시민 양성 위한 덕목은 상태가 아니라 행동에 초점 맞추는 것
       -> 객체지향 설계는 애플리케이션에 필요한 협력을 생각하고 협력에 참여하는데 필요한 행동을 생각 후 행동을 수행할 객체를 선택하는 방식으로 수행되야 함  
       상태는 이 행동을 위해 필요한 상태가 무엇인가 에서 나와야 함

  - 협력 안에서 객체의 행동은 완수해야 하는 책임 의미.  
    -> 어떤 책임이 필요한가 결정하는 과정이 전체 설계 주도해야함 (책임주도설계 Responsibility-Driven Design RDD)

## 은유와 객체

### 의인화(anthropomorphism)

현실속에서는 수동적인 존재가 소프트웨어 객체로 구현될 때는 능동적으로 변한다.
ex) 전화기는 스스로 통화버튼 누를 수 없으며 계좌는 스스로 금액 이체 불가  
프로그램의 세계에서는 다름

- 소프트웨어 안 구축되는 객체지향 세계는 현실을 모방한 것이 아니며, 현실 속 객체보다 더 많은 특징과 능력을 보유한 객체로 넘쳐난다.

### 은유 metaphor (transfer에서 유래)

현실세계와 객체지향 세계의 관계를 설명할수 있는 단어는 은유.  
-> 실제로 적용되지 않는 개념 이용해 다른 개념 서술하는 대화의 형태  
하나의 의미를 다른 것을 이용해 전달한다는 의미 가지고있음.
->현실과 소프트웨어세계의 객체 간 representational gap 표현적 차이, semantic gap 의미적 차이

- 프로그램내의 객체는 현실 속 객체에 대한 은유  
  ex) 현실속 전화기 스스로 전화 걸 수 없지만, 그 개념 이용해 소프트웨어 객체 묘사하면 전화를 걸 수 있다는 사실을 쉽게 이해하고 기억할 수 있다.

### 03 타입과 추상화

> 객체지향 패러다임은 객체라는 추상화를 통해 현실의 복잡성을 극복한다.

- 추상화

  - 어떤 양상, 세부사항 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 단순화해 복잡도를 극복하는 방법

  - 복잡성 다루기 위해 추상화는 두 차원에서 이뤄진다.
    1. 일반화: 구체적인 사물들 간 공통점 취하고 차이점 버림
    2. 단순화: 중요한 부분 강조 위해 불필요한 세부 사항 제거

### 그룹으로 나누어 단순화하기

앨리스 이야기에 등장하는 토끼와 트럼프 정원사,병사,신하,왕과 왕비 등은  
->'트럼프', '토끼'로 그룹화 가능.

- 그들의 외형으로부터 트럼프라는 그룹도출
- 인물들 각자의 세세한 차이는 무시하고 공통점만 취해 일반화했다.
- 이처럼 공통점 기반으로 객체들을 묶기 위한 그릇을 개념(CONCEPT)라고 함  
  EX) 도로를 누비는 차들을 자동차 라고 부르며, 하늘을 나는 교통수단을 비행기라고 부르는 것
- 개념을 이용해서 객체를 여러 그룹으로 분류(classification)
- 분류된 그룹의 각 객체는 instance라고 부름

### 개념의 3가지 관점

- 심볼: 개념을 가리키는 이름이나 명칭
- 내연,내재(intension): 개념의 의미를 나타냄.
- 외연(extension): 개념에 속하는 모든 객체의 집합(set)

ex)
앨리스 이야기에 등장하는 토끼와 트럼프 정원사,병사,신하,왕과 왕비 등은  
->'트럼프', '토끼'로 그룹화 가능.

- 심볼: '트럼프'
- 내연: 개념의 의미 몸이 납작하고, 카드모양을 한 등장인물  
  ->디테일한 모습 통해 개념을 객체에 적용할 수 있는지 판단.
- 외연: 개념에 속하는 인스턴스들이 모여 이뤄진 집합.  
  카드정원사, 왕과 왕비들, 병사들
